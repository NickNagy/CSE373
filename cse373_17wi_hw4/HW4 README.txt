Nick Nagy, CSE 373, Section AA, Chloe Lathe

1.
	adjacentVertices() - The method must first check if the given parameter is contained in the local vertexMap as a key. Since the HashMap is essentially a Set of Vertex keys, each pointing to a Set of Edges, containsKey() should have the same time-complexity as a Set's contains() method - which, according to the Java API is O(1) assuming the HashMap and HashSet are properly implemented. If the parameter is found in the Collection it will retrieve the corresponding set of Edges, and then iterate over each Edge in the Set to retrieve the neighboring Vertex objects. The number of Edges pointing out from a Vertex is the out-degree of a Vertex. The worst-case runtime of this method depends on the number of Edges that need to be iterated through for a given Vertex, so we can call this runtime O(d), where d is the out-degree of the Vertex parameter.

	edgeCost() - The method must first check if both parameters exist in the vertexMap. According to the Java API, the runtime for HashMap.containsKey() is O(1) assuming the HashMap is properly implemented. If both Vertex objects exist, the vertexMap retrieves the Set of Edges pointing out from Vertex a. To find the cost from a to b, we must first check that b is a neighbor of a, meaning in the worst-case all Edges in the retrieved Set will have to be checked. The number of Edges pointing out from a Vertex is the out-degree of a Vertex, so the worst-case runtime for this method is O(d), or the out-degree of Vertex a.

	If HashMap functionality fails then both methods will be at worst O(V) runtime, where V is the number of vertices in the graph keySet (the methods will have to check each existing Vertex to see if the parameters exist).

2.	
	The general rule is to not trust the client, and to deep-copy anything passed into the abstraction. In all methods that take parameters I checked to make sure the client does not try to pass a null value (and throw an exception if they do). I deep-copied all Edges and Vertices in the Collections passed to the constructor and copied the Vertex objects returned in adjacentVertices(). I did not have to deep copy everything, however. By making my fields immutable I could directly return my local Sets for the vertices() and edges() methods (I still initialized them as new HashSets rather than setting them equal to the parameters, because I was going to have to iterate through the parameters either way to check for illegally formatted variables). Because the fields of the Edge class are also immutable, I could return Edge.getWeight() in the edgeCost() method without making a copy of the weight.

3.
	The functionality of each method in MyGraph was straightforward to implement, so I spent some time making sure exceptions were thrown where they were supposed to and everything was running properly, and then focused on trying to break abstraction in my client class. Because the Vertex and Edge classes already protect abstraction by making their fields final, I did not have to worry about a client trying to change any of their fields correctly. I was more concerned about a client trying to set an existing Edge or Vertex to null, or re-initializing it to a new Edge or Vertex. This potential problem would arise when the vertices and edges are returned to the client. To assure that the Collections returned couldn't be manipulated I changed my fields to final (immutable), meaning they could not be changed after their construction. By deep-copying the Edges and Vertices in the constructor method before adding them to the local Collections, I ensured that nothing passed in or out by a client could be meddled with.